# Unix Programming
### **Posix Threads**  

Έστω ένας δυσδιάστατος πίνακας ακεραίων Α (ΝxN). Γράψτε ένα πρόγραμμα σε C το οποίο (με χρήση της βιβλιοθήκης των POSIX Threads) θα βρίσκει το 'μέγιστο' στοιχείο (*m)* του πίνακα Α. Για να πετύχετε το παραπάνω θα πρέπει αρχικά να εκκινήσετε στο πρόγραμμά σας ‘p’ threads, με σκοπό να ανατεθεί στη συνέχεια σε κάθε ένα από αυτά να υπολογίζει το επιμέρους μέγιστο Ν/p γραμμών του πίνακα (τα 'p', 'Ν', 'Α' θα πρέπει να τα δίνει ο χρήστης ή να τα διαβάζετε από αρχείο – επίσης θεωρήστε ότι το 'Ν' είναι ακέραιο πολλαπλάσιο του 'p'). Πιο συγκεκριμένα, το κάθε thread θα πρέπει αρχικά (α) να υπολογίζει τοπικά (σε μια τοπική μεταβλητή  –  π.χ.  local\_max)  τo  επιμέρους  μέγιστο  για  τις  γραμμές  του  πίνακα  που  του αναλογούν, και (β) να ενημερώνει στο τέλος με το τοπικό του μέγιστο μια κοινή μεταβλητή (π.χ. total\_max) η οποία θα αντιπροσωπεύει το τελικό μέγιστο του πίνακα Α. Το τελικό αυτό μέγιστο θα πρέπει στο τέλος να τυπώνεται στην οθόνη.  

Υπάρχει κάποιο «κρίσιμο τμήμα» στον κώδικά σας που απαιτεί προστασία ? Αν ναι, γράψτε επιπλέον τον κώδικα για την προστασία του κρίσιμου αυτού τμήματος. 

Δοκιμάστε να τρέξετε το πρόγραμμά σας για μεγάλα και πολύ μεγάλα ‘n’ (χρησιμοποιώντας για input αντίστοιχους πίνακες αρχικοποιημένους με τυχαίους αριθμούς) και μετρήστε τους χρόνους εκτέλεσης για ένα και περισσότερα από ένα threads (π.χ. 1, 2, 4 και 8 threads). 

### **Semaphores** 

Γράψτε ένα πρόγραμμα σε C, το οποίο θα χρησιμοποιεί την βιβλιοθήκη των POSIX Threads, και θα έχει ως αποτέλεσμα να τυπώνεται επαναληπτικά η ακολουθία: 

one, two, three, one, two, three ... 

Για να πετύχετε το παραπάνω θα πρέπει αρχικά να εκκινήσετε στο πρόγραμμά σας τρία (3) διαφορετικά threads (το ένα να τυπώνει ***<one>***, το άλλο να τυπώνει ***<two>*** και το τρίτο να τυπώνει ***<three>***), και στη συνέχεια να τα συγχρονίσετε κατάλληλα μεταξύ τους. Για τον απαιτούμενο συγχρονισμό θα πρέπει να χρησιμοποιήσετε **σημαφόρους**.  

### **Condition Variables**
Στη συνέχεια προσπαθήστε να δώσετε *(δεν ζητείται υποχρεωτικά)* μια εναλλακτική έκδοση του  προγράμματός  σας  χρησιμοποιώντας  για  τον  απαιτούμενο  συγχρονισμό  **condition variables** *(η προσπάθειά σας για την απαίτηση αυτή θα συνυπολογιστεί προσθετικά στον τελικό βαθμό της άσκησης – θα μετρήσει δηλαδή ως ‘bonus’)*.* 

### **Socket Programming (client - server)** 

Γράψτε δύο προγράμματα σε C, ένα πρόγραμμα **server** και έναν πρόγραμμα **client** (το οποίο θα μπορούν να το εκτελούν εν δυνάμει πολλοί clients – και να μπορούν να εξυπηρετούνται *ταυτόχρονα* από το server), τα οποία θα μπορούν να επικοινωνούν μεταξύ τους (με χρήση UNIX-domain stream sockets) επαναληπτικά ως εξής:  

- Ο client θα στέλνει στο server μία ακολουθία ακεραίων μήκους Ν, την οποία θα διαβάζει από το χρήστη. 
- Ο server αφού παραλάβει την ακολουθία θα υπολογίζει το μέσο όρο της και αν αυτός είναι πάνω από 20 θα στέλνει πίσω στον client τόσο (α) τον μέσο όρο που βρήκε όσο και (β) ένα κατάλληλο μήνυμα αποδοχής (π.χ. 'Sequence Ok'). Ειδάλλως θα στέλνει μόνο ένα μήνυμα αποτυχίας (π.χ. 'Check Failed').  
- Ο client θα πρέπει απλά μετά από κάθε επικοινωνία να τυπώνει την απάντηση του έστειλε ο server στην οθόνη, και να ζητά την επόμενη ακολουθία από το χρήστη. Η επικοινωνία θα τελειώνει (από πλευράς του client) όταν ο χρήστης δηλώσει ότι δεν επιθυμεί να δώσει άλλη ακολουθία προς έλεγχο. 

